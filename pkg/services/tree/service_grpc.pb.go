//*
// Service for working with CRDT tree.

// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.2.0
// - protoc             v4.25.1
// source: pkg/services/tree/service.proto

package tree

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.32.0 or later.
const _ = grpc.SupportPackageIsVersion7

// TreeServiceClient is the client API for TreeService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type TreeServiceClient interface {
	// Add adds new node to the tree. Invoked by a client.
	Add(ctx context.Context, in *AddRequest, opts ...grpc.CallOption) (*AddResponse, error)
	// AddByPath adds new node to the tree by path. Invoked by a client.
	AddByPath(ctx context.Context, in *AddByPathRequest, opts ...grpc.CallOption) (*AddByPathResponse, error)
	// Remove removes node from the tree. Invoked by a client.
	Remove(ctx context.Context, in *RemoveRequest, opts ...grpc.CallOption) (*RemoveResponse, error)
	// Move moves node from one parent to another. Invoked by a client.
	Move(ctx context.Context, in *MoveRequest, opts ...grpc.CallOption) (*MoveResponse, error)
	// GetNodeByPath returns list of IDs corresponding to a specific filepath.
	GetNodeByPath(ctx context.Context, in *GetNodeByPathRequest, opts ...grpc.CallOption) (*GetNodeByPathResponse, error)
	// GetSubTree returns tree corresponding to a specific node.
	GetSubTree(ctx context.Context, in *GetSubTreeRequest, opts ...grpc.CallOption) (TreeService_GetSubTreeClient, error)
	// TreeList return list of the existing trees in the container.
	TreeList(ctx context.Context, in *TreeListRequest, opts ...grpc.CallOption) (*TreeListResponse, error)
	// Apply pushes log operation from another node to the current.
	// The request must be signed by a container node.
	Apply(ctx context.Context, in *ApplyRequest, opts ...grpc.CallOption) (*ApplyResponse, error)
	// GetOpLog returns a stream of logged operations starting from some height.
	GetOpLog(ctx context.Context, in *GetOpLogRequest, opts ...grpc.CallOption) (TreeService_GetOpLogClient, error)
	// Healthcheck is a dummy rpc to check service availability
	Healthcheck(ctx context.Context, in *HealthcheckRequest, opts ...grpc.CallOption) (*HealthcheckResponse, error)
}

type treeServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewTreeServiceClient(cc grpc.ClientConnInterface) TreeServiceClient {
	return &treeServiceClient{cc}
}

func (c *treeServiceClient) Add(ctx context.Context, in *AddRequest, opts ...grpc.CallOption) (*AddResponse, error) {
	out := new(AddResponse)
	err := c.cc.Invoke(ctx, "/tree.TreeService/Add", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *treeServiceClient) AddByPath(ctx context.Context, in *AddByPathRequest, opts ...grpc.CallOption) (*AddByPathResponse, error) {
	out := new(AddByPathResponse)
	err := c.cc.Invoke(ctx, "/tree.TreeService/AddByPath", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *treeServiceClient) Remove(ctx context.Context, in *RemoveRequest, opts ...grpc.CallOption) (*RemoveResponse, error) {
	out := new(RemoveResponse)
	err := c.cc.Invoke(ctx, "/tree.TreeService/Remove", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *treeServiceClient) Move(ctx context.Context, in *MoveRequest, opts ...grpc.CallOption) (*MoveResponse, error) {
	out := new(MoveResponse)
	err := c.cc.Invoke(ctx, "/tree.TreeService/Move", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *treeServiceClient) GetNodeByPath(ctx context.Context, in *GetNodeByPathRequest, opts ...grpc.CallOption) (*GetNodeByPathResponse, error) {
	out := new(GetNodeByPathResponse)
	err := c.cc.Invoke(ctx, "/tree.TreeService/GetNodeByPath", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *treeServiceClient) GetSubTree(ctx context.Context, in *GetSubTreeRequest, opts ...grpc.CallOption) (TreeService_GetSubTreeClient, error) {
	stream, err := c.cc.NewStream(ctx, &TreeService_ServiceDesc.Streams[0], "/tree.TreeService/GetSubTree", opts...)
	if err != nil {
		return nil, err
	}
	x := &treeServiceGetSubTreeClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type TreeService_GetSubTreeClient interface {
	Recv() (*GetSubTreeResponse, error)
	grpc.ClientStream
}

type treeServiceGetSubTreeClient struct {
	grpc.ClientStream
}

func (x *treeServiceGetSubTreeClient) Recv() (*GetSubTreeResponse, error) {
	m := new(GetSubTreeResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *treeServiceClient) TreeList(ctx context.Context, in *TreeListRequest, opts ...grpc.CallOption) (*TreeListResponse, error) {
	out := new(TreeListResponse)
	err := c.cc.Invoke(ctx, "/tree.TreeService/TreeList", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *treeServiceClient) Apply(ctx context.Context, in *ApplyRequest, opts ...grpc.CallOption) (*ApplyResponse, error) {
	out := new(ApplyResponse)
	err := c.cc.Invoke(ctx, "/tree.TreeService/Apply", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *treeServiceClient) GetOpLog(ctx context.Context, in *GetOpLogRequest, opts ...grpc.CallOption) (TreeService_GetOpLogClient, error) {
	stream, err := c.cc.NewStream(ctx, &TreeService_ServiceDesc.Streams[1], "/tree.TreeService/GetOpLog", opts...)
	if err != nil {
		return nil, err
	}
	x := &treeServiceGetOpLogClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type TreeService_GetOpLogClient interface {
	Recv() (*GetOpLogResponse, error)
	grpc.ClientStream
}

type treeServiceGetOpLogClient struct {
	grpc.ClientStream
}

func (x *treeServiceGetOpLogClient) Recv() (*GetOpLogResponse, error) {
	m := new(GetOpLogResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *treeServiceClient) Healthcheck(ctx context.Context, in *HealthcheckRequest, opts ...grpc.CallOption) (*HealthcheckResponse, error) {
	out := new(HealthcheckResponse)
	err := c.cc.Invoke(ctx, "/tree.TreeService/Healthcheck", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// TreeServiceServer is the server API for TreeService service.
// All implementations should embed UnimplementedTreeServiceServer
// for forward compatibility
type TreeServiceServer interface {
	// Add adds new node to the tree. Invoked by a client.
	Add(context.Context, *AddRequest) (*AddResponse, error)
	// AddByPath adds new node to the tree by path. Invoked by a client.
	AddByPath(context.Context, *AddByPathRequest) (*AddByPathResponse, error)
	// Remove removes node from the tree. Invoked by a client.
	Remove(context.Context, *RemoveRequest) (*RemoveResponse, error)
	// Move moves node from one parent to another. Invoked by a client.
	Move(context.Context, *MoveRequest) (*MoveResponse, error)
	// GetNodeByPath returns list of IDs corresponding to a specific filepath.
	GetNodeByPath(context.Context, *GetNodeByPathRequest) (*GetNodeByPathResponse, error)
	// GetSubTree returns tree corresponding to a specific node.
	GetSubTree(*GetSubTreeRequest, TreeService_GetSubTreeServer) error
	// TreeList return list of the existing trees in the container.
	TreeList(context.Context, *TreeListRequest) (*TreeListResponse, error)
	// Apply pushes log operation from another node to the current.
	// The request must be signed by a container node.
	Apply(context.Context, *ApplyRequest) (*ApplyResponse, error)
	// GetOpLog returns a stream of logged operations starting from some height.
	GetOpLog(*GetOpLogRequest, TreeService_GetOpLogServer) error
	// Healthcheck is a dummy rpc to check service availability
	Healthcheck(context.Context, *HealthcheckRequest) (*HealthcheckResponse, error)
}

// UnimplementedTreeServiceServer should be embedded to have forward compatible implementations.
type UnimplementedTreeServiceServer struct {
}

func (UnimplementedTreeServiceServer) Add(context.Context, *AddRequest) (*AddResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Add not implemented")
}
func (UnimplementedTreeServiceServer) AddByPath(context.Context, *AddByPathRequest) (*AddByPathResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AddByPath not implemented")
}
func (UnimplementedTreeServiceServer) Remove(context.Context, *RemoveRequest) (*RemoveResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Remove not implemented")
}
func (UnimplementedTreeServiceServer) Move(context.Context, *MoveRequest) (*MoveResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Move not implemented")
}
func (UnimplementedTreeServiceServer) GetNodeByPath(context.Context, *GetNodeByPathRequest) (*GetNodeByPathResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetNodeByPath not implemented")
}
func (UnimplementedTreeServiceServer) GetSubTree(*GetSubTreeRequest, TreeService_GetSubTreeServer) error {
	return status.Errorf(codes.Unimplemented, "method GetSubTree not implemented")
}
func (UnimplementedTreeServiceServer) TreeList(context.Context, *TreeListRequest) (*TreeListResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method TreeList not implemented")
}
func (UnimplementedTreeServiceServer) Apply(context.Context, *ApplyRequest) (*ApplyResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Apply not implemented")
}
func (UnimplementedTreeServiceServer) GetOpLog(*GetOpLogRequest, TreeService_GetOpLogServer) error {
	return status.Errorf(codes.Unimplemented, "method GetOpLog not implemented")
}
func (UnimplementedTreeServiceServer) Healthcheck(context.Context, *HealthcheckRequest) (*HealthcheckResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Healthcheck not implemented")
}

// UnsafeTreeServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to TreeServiceServer will
// result in compilation errors.
type UnsafeTreeServiceServer interface {
	mustEmbedUnimplementedTreeServiceServer()
}

func RegisterTreeServiceServer(s grpc.ServiceRegistrar, srv TreeServiceServer) {
	s.RegisterService(&TreeService_ServiceDesc, srv)
}

func _TreeService_Add_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AddRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TreeServiceServer).Add(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/tree.TreeService/Add",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TreeServiceServer).Add(ctx, req.(*AddRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TreeService_AddByPath_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AddByPathRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TreeServiceServer).AddByPath(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/tree.TreeService/AddByPath",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TreeServiceServer).AddByPath(ctx, req.(*AddByPathRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TreeService_Remove_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RemoveRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TreeServiceServer).Remove(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/tree.TreeService/Remove",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TreeServiceServer).Remove(ctx, req.(*RemoveRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TreeService_Move_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MoveRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TreeServiceServer).Move(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/tree.TreeService/Move",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TreeServiceServer).Move(ctx, req.(*MoveRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TreeService_GetNodeByPath_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetNodeByPathRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TreeServiceServer).GetNodeByPath(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/tree.TreeService/GetNodeByPath",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TreeServiceServer).GetNodeByPath(ctx, req.(*GetNodeByPathRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TreeService_GetSubTree_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(GetSubTreeRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(TreeServiceServer).GetSubTree(m, &treeServiceGetSubTreeServer{stream})
}

type TreeService_GetSubTreeServer interface {
	Send(*GetSubTreeResponse) error
	grpc.ServerStream
}

type treeServiceGetSubTreeServer struct {
	grpc.ServerStream
}

func (x *treeServiceGetSubTreeServer) Send(m *GetSubTreeResponse) error {
	return x.ServerStream.SendMsg(m)
}

func _TreeService_TreeList_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TreeListRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TreeServiceServer).TreeList(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/tree.TreeService/TreeList",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TreeServiceServer).TreeList(ctx, req.(*TreeListRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TreeService_Apply_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ApplyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TreeServiceServer).Apply(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/tree.TreeService/Apply",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TreeServiceServer).Apply(ctx, req.(*ApplyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TreeService_GetOpLog_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(GetOpLogRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(TreeServiceServer).GetOpLog(m, &treeServiceGetOpLogServer{stream})
}

type TreeService_GetOpLogServer interface {
	Send(*GetOpLogResponse) error
	grpc.ServerStream
}

type treeServiceGetOpLogServer struct {
	grpc.ServerStream
}

func (x *treeServiceGetOpLogServer) Send(m *GetOpLogResponse) error {
	return x.ServerStream.SendMsg(m)
}

func _TreeService_Healthcheck_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(HealthcheckRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TreeServiceServer).Healthcheck(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/tree.TreeService/Healthcheck",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TreeServiceServer).Healthcheck(ctx, req.(*HealthcheckRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// TreeService_ServiceDesc is the grpc.ServiceDesc for TreeService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var TreeService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "tree.TreeService",
	HandlerType: (*TreeServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Add",
			Handler:    _TreeService_Add_Handler,
		},
		{
			MethodName: "AddByPath",
			Handler:    _TreeService_AddByPath_Handler,
		},
		{
			MethodName: "Remove",
			Handler:    _TreeService_Remove_Handler,
		},
		{
			MethodName: "Move",
			Handler:    _TreeService_Move_Handler,
		},
		{
			MethodName: "GetNodeByPath",
			Handler:    _TreeService_GetNodeByPath_Handler,
		},
		{
			MethodName: "TreeList",
			Handler:    _TreeService_TreeList_Handler,
		},
		{
			MethodName: "Apply",
			Handler:    _TreeService_Apply_Handler,
		},
		{
			MethodName: "Healthcheck",
			Handler:    _TreeService_Healthcheck_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "GetSubTree",
			Handler:       _TreeService_GetSubTree_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "GetOpLog",
			Handler:       _TreeService_GetOpLog_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "pkg/services/tree/service.proto",
}
